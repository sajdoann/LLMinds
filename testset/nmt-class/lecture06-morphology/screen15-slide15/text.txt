 So here is an illustration how that goes with the kneecaps thing. On the source side we have the kneecaps. That's the first element in that vector. And we first morphologically analyze it. So we will know that the lemma of this, the lemmas of these two words are knee and cap. And also we will know that the first word is an adjective and the second word is a noun in plural. And we have this sequence of processes that was predefined by the author of the system. And that sequence says that first translate, then generate, then translate, and then generate to arrive at the final thing. So let's go into the details. The first translation step translates the lemma into lemma. So the target side, again a three factor word, is still very much underspecified. But we already know that kneecap is Češka. That is the lemma, the base form of that of that word. But we don't know its word form in the final sentence. And also we don't know the morphological tag of that. Then we can use the generation step. This generation step is based on the monolingual corpus of the target side. And this searches in what all morphological tags can I possibly produce that word. So it will know from the monolingual corpus that Češka can be put in in the singular of nominative, singular of genitive, and all other cases. And then in plural, singular, genitive, nominative, all the possible tag combinations that are valid for this lemma. Then when we again consult the source sentence. So we will use a translation step that compares the source side morphological tag with the target side morphological tag. And we know in the source that this was a plural. So it will a lot more likely to use plural on the target side as well. And it is not indicated here in the picture. But these translation options, these candidates are actually obviously scored. They have some score associated with them and they are sorted according to the score. So at this stage the ordering changes because the plural, all the plural candidates become much more likely than the singular candidates. There are counter examples. For example in Czech when you say in Czech the police investigate, then in Czech we would use singular whereas in English the police serves as plural. So the singular and plural are not always in line across the languages. But in general, probabilistically the tag will be in relation. Yeah. So there we have created many more options. And then we can use the final step of the generation step which takes the morphological tag. and the lemma and it produces the correct, the particular correct form of that word. And this is again based on the monolingual data only. So it has the capacity to produce a word form which was never accessible to the, to the, to the, to the parallel data or was never seen in the parallel data. So this is one way to think about this and I'll just hint it now and you will see an example of this later. One way to see this is to see it as, as the sequence of join, joins of SQL tables. And instead of having one table which lists the word forms in source language and target language, you have now two separate tables. One that lists all the translations of lemmas to lemmas and that's shorter. And you have another separate table which maps source text to the target text. That's again shorter. And you do a a product of these two tables. You do join. And you also have these tables that, that check the vertical coherence, the generation step to check the, the validity of combining a particle lemma with a particle tag. So this sequence of, of joins that has varying complexity. And you know that in, in databases you consider, you, you search for the optimal order of joining tables. This happens here as well. But this search is not, is not automated in any way. It's up to the author of the system to, to put the, um, uh, put the generation and mapping steps in, in, uh, reasonable order. Uh, if you screw it up, if you do a wrong ordering, if your data is, uh, not the way that you think, uh, uh, what happens is that you will generate too many candidates in one of these stages. You will have to prune them to, to keep them in the memory, uh, but you're pruning them without any contact. and you will lose the good ones. Uh, so the idea is to, uh, do this join of tables, uh, in, in a way so that the lists of candidates do not grow beyond the capacity of your system. Uh, by changing the order, uh, you can, uh, you can reduce the, uh, the memory complexity of the, uh, of the joint operation, so to say.